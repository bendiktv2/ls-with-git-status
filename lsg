#!/usr/bin/env bash
##
# List files, including git information in the output.
# We accept switches for ls and attempt to mimic the usual behaviour of the tool.
#

# The command we'll actually run for listing.
# Replacing this with 'gls' on MacOS with GNU coreutils will run the gnu version instead.
ls=ls

ls_switches=()
warned=false
# Track the switches we pass to ls in ls_switches
while [[ "${1:0:1}" == '-' && "$1" != '--' ]] ; do
    switch="$1"
    # Certain switches are not supported and must be ignored.
    if [[ "$switch" =~ ^-[^-] ]] ; then
        # Single '-' switch
        while [[ "$switch" =~ ^(.*)([Cx])(.*)$ ]] ; do
            # Multi column format was requested.
            # That's not possible for us, so we trim it out.
            switch="${BASH_REMATCH[1]}${BASH_REMATCH[3]}"
            echo "Warning: Ignoring switch -${BASH_REMATCH[2]}" >&2
            warned=true
        done
    fi
    if [[ "$switch" != '-' ]] ; then
        ls_switches+=("$switch")
    fi
    shift
done

if $warned ; then
    # A blank line to separate our warnings from the main output
    echo >&2
fi

# Include colouring
if [[ "$(uname -s)" == 'Darwin' && "$ls" == 'ls' ]] ; then
    export CLICOLOR_FORCE=1
    ls_switches+=('-G')
else
    ls_switches+=('--color=always')
fi

if [[ "$1" == '--' ]] ; then
    ls_switches+=('--')
    shift
fi

ls_dirs=("$@")
if [[ "${#ls_dirs[@]}" == 0 ]] ; then
    ls_dirs=('.')
fi


# Pick colours from the git configuration to match user preference
color_branch="$(git config --get-color color.status.branch 'cyan')"
color_added="$(git config --get-color color.status.added 'green')"
color_updated="$(git config --get-color color.status.updated 'green')"
color_changed="$(git config --get-color color.status.changed 'yellow')"
color_untracked="$(git config --get-color color.status.untracked 'red')"
color_unmerged="$(git config --get-color color.status.unmerged 'red bold')"
# I don't think ignored is a real status colour, and it actually comes out in red
# when you use `git status --ignored`, however, white makes more sense to me,
# as we don't care about those files.
color_ignored="$(git config --get-color color.status.ignored 'dim')"
color_reset="$(git config --get-color '' 'reset')"
color_bold="$(git config --get-color '' 'bold')"


# Configuration here matches my shell prompt
prompt_git_delta=$'\033[1;34m'
prompt_git_reset=$'\033[0m'

# Symbols to use in the prompt, based on what looks reasonable in the terminal
# (although we could be remote, it's less common, so we try to match local system type)
if [[ "$(uname -s)" == 'Darwin' ]] ; then
    prompt_git_ahead_symbol="↑"
    prompt_git_behind_symbol="↓"
else
    prompt_git_ahead_symbol="￪"
    prompt_git_behind_symbol="￬"
fi


##
# Print the relative location compared to the upstream.
#
# That is, we print an up arrow with a number if there are changes to push,
# and a down arrow with a number for changes we can pull.
function git_relative_state() {
    local dir="$1"
    local upstream
    local upstreamrefname
    local behind
    local ahead
    local delta

    cd $1

    # Check if we have an upstream configured
    upstream="$(git for-each-ref --format='%(upstream:short)' "$(git symbolic-ref -q HEAD)")"
    upstreamrefname='upstream'
    if [[ "$upstream" == '' ]] ; then
        upstream="$(git for-each-ref --format='%(push:short)' "$(git symbolic-ref -q HEAD)")"
        upstreamrefname='push'
    fi
    if [[ "$upstream" != '' ]] ; then
        behind="$(git rev-list --count "@..@{${upstreamrefname}}" 2>/dev/null)"
        ahead="$(git rev-list --count "@{${upstreamrefname}}..@" 2>/dev/null)"
        if [[ "${ahead}${behind}" != '' ]] ; then
            if [[ "${behind}" != '0' ]] ; then
                behind="$prompt_git_behind_symbol$behind"
            else
                behind=''
            fi
            if [[ "${ahead}" != '0' ]] ; then
                ahead="$prompt_git_ahead_symbol$ahead"
            else
                ahead=''
            fi
        fi
    fi

    if [[ "${ahead}${behind}" != '' ]] ; then
        delta="$prompt_git_delta$ahead$behind$prompt_git_reset"
    fi
    echo "$delta"
}


##
# Print a description of the line changes for a given file (in the cache or in the working tree).
function git_line_changes() {
    local file="$1"
    local where="$2"
    local arg=''
    local result=''
    local diff_line added_lines deleted_lines total_lines
    local oldmode newmode changemode
    local delflags addflags flags
    if [[ "$where" == "cache" ]] ; then
        arg="--cached"
    elif [[ "$where" == "tree" ]] ; then
        arg=""
    fi

    diff_line="$(git diff $arg --summary --numstat "$spec/$name" | expand)"
    if [[ "$diff_line" =~ ^([0-9]+)\ +([0-9]+) ]] ; then
        added_lines="${BASH_REMATCH[1]}"
        deleted_lines="${BASH_REMATCH[2]}"
        total_lines="$(( added_lines + deleted_lines ))"
        if [[ "$total_lines" != '0' ]] ; then
            result="${total_lines} line"
            if [[ "${total_lines}" != 1 ]] ; then
                result="${result}s"
            fi
        fi
    fi
    echo "$result"
}


has_associative_arrays=false
if [[ "${BASH_VERSION%%.*}" -ge 4 ]] ; then
    has_associative_arrays=true
fi


# I'm going to entirely ignore the problems of filenames with spaces in.
first=true
for spec in "${ls_dirs[@]}" ; do
    if [[ "${#ls_dirs[@]}" -gt 1 ]] ; then
        # Mimic the ls behaviour of writing out the directory name when listing multiple dirs
        if ! $first ; then
            echo
        fi
        first=false
        echo "${color_bold}$spec${color_reset}:"
    fi
    if [[ -e "$spec" ]] ; then
        in_git="$(cd "$spec" && git rev-parse --is-inside-work-tree 2> /dev/null)"
    else
        in_git=false
    fi

    longest_line="$($ls "${ls_switches[@]}" "$spec" 2> /dev/null \
                        | sed $'s/\x1B\\[[0-9;]*[a-zA-Z]//g' \
                        | expand \
                        | awk '{ if ( length > x ) { x = length } } END{ print x }')"

    if $in_git && $has_associative_arrays ; then
        # If we have associative arrays, we can make this faster by
        # listing the git status of all the files.
        declare -A git_status
        if [[ -d "$spec" ]] ; then
            cd "$spec"
            while IFS= read -r line ; do
                name="${line:3:${#line}}"
                git_status[$name]="$line"
            done < <(git status --porcelain --ignored 2> /dev/null)
            cd - > /dev/null
        fi
    else
        git_status=()
    fi

    $ls "${ls_switches[@]}" "$spec" \
        | while read line ; do
            label=''
            name=''
            line_without_colouring="$(echo "$line" | sed $'s/\x1B\\[[0-9;]*[a-zA-Z]//g')"
            line_length="${#line_without_colouring}"

            if [[ "$line_without_colouring" == '' ]] ; then
                echo
                continue
            fi

            # If -R was specified then we'll have come lines that are formed as
            # <directory>:
            # which indicates a new directory has been entered... so we need to
            # take account of this.
            if [[ "$line_without_colouring" =~ ^(.*):$ ]] ; then
                spec="${BASH_REMATCH[1]}"
                echo "${color_bold}$spec${color_reset}:"
                continue
            fi

            if [[ "$line_without_colouring" =~ \ ([^\ ]+)$ || \
                  "$line_without_colouring" =~ ^([^\ ]+)$ ]] ; then
                name="${BASH_REMATCH[1]}"
            fi

            if [[ -d "$spec/$name/.git" || -f "$spec/$name/.git" ]] ; then
                # That object is a directory, and is a git repository.
                branch="$(git --git-dir="$spec/$name/.git" name-rev --exclude origin/HEAD --name-only HEAD 2> /dev/null)"
                branch="${branch#remotes/}"
                delta="$(git_relative_state "$spec/$name")"
                label="(${color_branch}${branch}${delta}${color_reset})"

            elif $in_git && [[ -f "$spec/$name" ]] ; then
                # On files, check if the file is up to date or not
                if $has_associative_arrays ; then
                    state="${git_status[$name]}"
                else
                    state="$(cd "$spec" ; git status --porcelain --ignored "$name" 2> /dev/null)"
                fi
                state="${state:-  }"
                state="${state:0:2}"
                state_x="${state:0:1}"
                state_y="${state:1:2}"
                case "$state" in
                    'DD') label="${color_unmerged}unmerged{$color_reset}, ${color_changed}both deleted${color_reset}" ; ;;
                    'AU') label="${color_unmerged}unmerged{$color_reset}, ${color_changed}added by us${color_reset}" ; ;;
                    'UD') label="${color_unmerged}unmerged{$color_reset}, ${color_changed}deleted by them${color_reset}" ; ;;
                    'UA') label="${color_unmerged}unmerged{$color_reset}, ${color_changed}added by them${color_reset}" ; ;;
                    'DU') label="${color_unmerged}unmerged{$color_reset}, ${color_changed}deleted by us${color_reset}" ; ;;
                    'AA') label="${color_unmerged}unmerged{$color_reset}, ${color_changed}both added${color_reset}" ; ;;
                    'UU') label="${color_unmerged}unmerged{$color_reset}, ${color_changed}both modified${color_reset}" ; ;;
                    '??') label="${color_untracked}untracked${color_reset}" ; ;;
                    '!!') label="${color_ignored}ignored${color_reset}" ; ;;
                    *)
                        in_index=''
                        in_tree=''
                        case "$state_x" in
                            ' ') : ;; # No change to index
                            'M') in_index="${color_updated}staged"
                                changes="$(git_line_changes "$spec/$name" tree)"
                                in_index="${in_index}${changes:+, $changes}"
                                ;;
                            'A') in_index="${color_added}added" ; ;;
                            'D') in_index="${color_updated}deleted" ; ;;
                            'R') in_index="${color_updated}renamed" ; ;;
                            'C') in_index="${color_added}copied" ; ;;
                            *) in_tree="?$state_x?"
                        esac
                        in_index="${in_index:+$in_index$color_reset}"
                        case "$state_y" in
                            ' ') : ;; # No change to worktree
                            'M') in_tree="${color_changed}modified locally"
                                changes="$(git_line_changes "$spec/$name" tree)"
                                in_tree="${in_tree}${changes:+, $changes}"
                                ;;
                            'A') in_tree="${color_changed}added locally" ; ;;
                            'D') in_tree="${color_changed}deleted locally" ; ;;
                            *) in_tree="?$state_y?"
                        esac
                        in_tree="${in_tree:+$in_tree$color_reset}"
                        if [[ "$in_index" != '' && "$in_tree" != '' ]] ; then
                            label="$in_index+$in_tree"
                        else
                            label="$in_index$in_tree"
                        fi
                        ;;
                esac

                if [[ "$label" != "" ]] ; then
                    label="{$label}"
                fi
            fi
            if [[ "$label" != '' ]] ; then
                printf "%s  %*s%s\n" "$line" $((longest_line - line_length)) "" "$label"
            else
                echo "$line"
            fi
          done
done
